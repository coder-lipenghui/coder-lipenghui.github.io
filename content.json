{"pages":[{"title":"about","text":"程序员，有一个漂亮老婆和两只猫。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Unity使用jenkins打包","text":"unity使用命令行打包的时候是不能再开一个unity编辑器窗口进行工作的，所以常规有一个额外的打包服务器。一般手游都需要接SDK，所以常规是导出一个androidstudio(IL2cpp)工程 1.基础配置1.1 安装jenkins在官网下载jenkins安装包即可。jenkins需要填一个jdk路径，所以就需要先下载一个jdk 1.8 1.2 配置JDK- Manage Jenkins→Global Tool Configuration→JDK。 - 设置JDK - 别名：jdk 1.8 - JAVA_HOME: *1步骤中下载的jdk安装路径，如果是默认安装则在 C:\\Program Files\\Java\\jdk1.8.0_31* 1.3 配置Gradle- 安装Gradle - Manage Jenkins→Global Tool Configuration→Gradle。 - name: gradle版本号 - 我勾选了Install automatically，选择了一个6.8的版本 - 设置GRADLE_USER_HOME - Dashboard→Manage Jenkins→Configure System→Environment variables→add - key:GRADLE_USER_HOME - value：C:\\Users\\admin\\.gradle\\wrapper\\dists\\gradle-6.8-bin\\1jblhjyydfkclfzx1agp92nyl\\gradle-6.8 2.创建任务 创建一个自由任务1 General→使用自定义的工作空间→unity导出的工程下的launcher目录2 构建→Invoke Gradle→选择安装的版本6.83 Tasks：clean assembleRelease —stacktrace —debug3.其他选项完成1、2两个步骤就可以打出一个默认unity工程的apk了。实际开发过程中会有一些其他的设置 3.1 Flaovrs当接入不同渠道后需要不同渠道进行打包,Android工程需要做好Flavors的支持。 3.1.1 安卓工程配置Flavors1234567891011121314151617181920安卓工程Gradle示例:productFlavors { develop { dimension 'default' applicationId 'com.yileweb.rome' versionCode VERSION_CODE.toInteger() versionName VERSION_NAME.toString() buildConfigField &quot;int&quot;,&quot;game_distribution&quot;,&quot;&quot; buildConfigField &quot;String&quot;,&quot;distribution_appId&quot;,&quot;\\\\&quot;\\\\&quot;&quot; buildConfigField &quot;String&quot;,&quot;distribution_appKey&quot;,&quot;\\\\&quot;\\\\&quot;&quot; buildConfigField &quot;String&quot;,&quot;game_channel&quot;,&quot;\\\\&quot;\\\\&quot;&quot; buildConfigField &quot;String&quot;,&quot;bugly_id&quot;,&quot;\\\\&quot;\\\\&quot;&quot; manifestPlaceholders=[ &quot;game_name&quot;:&quot;显示名称&quot;, &quot;game_icon&quot;:&quot;@mipmap/app_icon&quot; ] } } 3.1.2 Jenkins配置 job-&gt;general-&gt;This project is parameterized增加参数 BUILD_TYPE： 固定 Debug 跟Release BUILD_FLAVOR：productFlavors下的flavorsName 例：Default VERSION_CODE：版本id VERSOIN_name：版本Name BUILD_TIME：构建时间(需要安装Date Parameter插件) job-&gt;构建-&gt;Gradle-&gt;高级-&gt;勾选Pass all job parameters as Project properties(将上述参数注入到Gradle.propertys中) job-&gt;构建-&gt;Gradle-&gt;task变更为 clean assemble${BUILD_FLAVOR}${BUILD_TYPE} 3.2 构建完成后下载APK3.2.1 Tomcat下载Tomcat一路下一步安装 3.2.2 构建日志增加下载链接 允许html格式：Dashboard -&gt;Configure Global Security-&gt;标记格式器-&gt;Safe HTML 追加链接：job-&gt;构建后操作-&gt;新增 SetBuild description -&gt; Description 1&lt;a href='&lt;http://172.16.61.14:9090/download/DGQST-${BUILD_FLAVOR}-${BUILD_TYPE}-${VERSION_CODE}-${BUILD_TIME}.apk&gt;'&gt;APK下载链接&lt;/a&gt; 下载链接中的文件名需要跟Gradle脚本中的输出包名对应起来 12345678910111213141516android.applicationVariants.all { variant -&gt; variant.outputs.all { output -&gt; println variant.buildType def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) { def time=BUILD_TIME.toString(); def tn=variant.buildType.name tn=tn.replace('release','Release') tn=tn.replace('debug','Debug') def fileName = APK_NAME.toString()+&quot;-&quot;+variant.productFlavors[0].name+&quot;-&quot;+tn+&quot;-&quot;+variant.productFlavors[0].versionCode+&quot;-&quot;+time+&quot;.apk&quot; println(&quot;=========&gt;&gt;&gt;&gt;&gt;&gt;:&quot;+fileName) //3.0之后绝对路劲不被允许了 outputFileName=new File(&quot;../../../../../../../../../../download/&quot;,fileName) } } }","link":"/2022/02/27/Unity%E4%BD%BF%E7%94%A8jenkins%E6%89%93%E5%8C%85/"},{"title":"Hello World","text":"仅记录生活及工作中的琐事","link":"/2022/02/26/hello-world/"},{"title":"《克拉拉与太阳》","text":"可能是因为悬疑小说看多了，我总感觉最后的乔西在拉开窗帘沐浴在太阳中的时候应该是去世了。从《远山淡影》这个书里面读到的石黑一雄风格就是网上或者书评中写到的“时间、记忆、自我欺骗”手法来看当时的故事就是两个感觉完全不同的故事最后合并在一条故事线上。那么如果用同等的感官来看克拉拉这个故事 我总感觉乔西应该是去世 克拉拉一直扮演者乔西直到母亲从伤痛中走出来离开家 把克拉拉放进阁楼。 小说整体感觉一般。既没有科幻的感觉，也没有普通故事的阅读感。石黑一雄的写作水平感觉极其不稳定。","link":"/2022/02/27/%E3%80%8A%E5%85%8B%E6%8B%89%E6%8B%89%E4%B8%8E%E5%A4%AA%E9%98%B3%E3%80%8B/"},{"title":"《人月神话》","text":"布鲁克斯 2. 人月神话 提前预留足够的测试时间 开发并推行称产率图表、缺陷率、估算规则 pingcode的速率图、燃尽图 缺陷率。总结归纳作为前车之鉴 缺乏合理的时间进度，是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大 围绕成本核算的估计技术，混淆了工作量和项目进展。人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。 想进度落后的项目中增加人手，会是进度更加落后(任务重新分配、沟通成本、培训成本、原有任务中断)4. 系统设计 为了获得概念完整性，设计必须有一个人或者具有共识的小型团队来完成。5. 画蛇添足 这部分内容对应PMP中的范围，即：做且仅做。防止范围蔓延而带来的额外成本。 范围蔓延在游戏项目中应该属于最常见的事情，游戏功能、玩法经常改动6. 贯彻执行 手册/文档 在游戏项目中，最应该做这部分的应该是一些中台技术(SDK、游戏后台数据上报、CI/CD)及引擎优化建议；因为游戏类型不一样(MMO\\FPS\\MOBA)除了上述一些通用接入类型的事情，很难总结出一些有用内容，以及没有那么多时间来写项目手册；换皮版本基本也还是原版人马接着做。所以基于项目的手册 在游戏行业基本不受重视。 会议 会议目的是为了及时发现问题，提前规避及解决风险及信息共享。常规而言都是周会、月会进行跟进。在敏捷开发中会议更为频繁，但目的是一样的。但敏捷开发的每日站会很容易流于形式至消失。 会议记录 会议记录留痕在我看来是个很重要的东西，记录每个阶段的问题及改进方向，作为前车之鉴的知识储备。 现在在线协作文档自带的会议模板基本就很好用了，如果没有内网限制不妨试一下(Confluance/PingCode的WIKi/语雀/腾讯文档/石墨) 测试 唉 7.为什么巴比伦塔会失败 缺乏交流以及交流的结果-组织 团队应该以尽可能多的方式进行相互之间的交流:非正式、常规项目会议，会上进行简要的技术陈述、共享的正式项目工作手机以及电子邮件。 大团队 产品负责人主导 小团队 产品负责人打杂 12.干将莫邪12.1 目标机器这部分可以理解为手游开发中的最低适配机型，确定好最低需要适配的机型后尽力保证在最低要求手机上流畅运行。 12.3 高级语言和交互式编程 *高级语言: 高级语言的主要原因是生产率和调试速度。 就目前的Unity而言，使用lua的项目占比依然很大。目前而言，从招人、培训、社区等方面而言 lua的确有优势，但随着游戏要求越来越高 lua在效率、调试、代码质量上面的问题也会随之加剧。在出现新解决方案,例如HybridCLR我的个人建议是积极适配(起码目前我们项目是使用了) 13.整体部分13.1 剔除bug的设计 防范bug的定义 测试规格说明 自顶向下的设计 其中关于自顶向下的设计这一则，对策划也尤为重要。一套自洽的产出、玩法等能很大程度的避免项目中后期因为体验不好进而带来的返工。14.祸起萧墙14.1 有效的里程碑 里程碑的选择只有一个原则，那就是:里程碑必须是具体的、特定的、可度量的事件，能够清晰定义。 里程碑有明显边界和没有歧义，比它容易被老板核实更为重要 好的里程碑对团队来说实际上是一项服务，可以用来向项目经理提出合理要求的一项 服务，而不确切的里程碑是难以处理的负担。 慢性进度偏离同样也是士气杀手14.2 关键路径(PERT)14.2.1 三时估算:$t_i = (a_i + b_i + 4c_i) / 6$公式中：$t_i$:工作i的平均持续时间$a_i$:乐观估计时间$b_i$:悲观估计时间$c_i$:正常估计时间扩充: 方差公式$σ_i^2 = [(b_i – a_i) / 6]^2$14.2.2主要作用: 标识出项目的关键路径，以明确项目活动的重点，便于优化对项目活动的资源分配 当管理者想计划缩短项目完成时间，节省成本时，就要把考虑的重点放在关键路径上 在资源分配发生矛盾时，可适当调动非关键路径上活动的资源去支持关键路径上的活动，以最有效地保证项目的完成进度 采用 PERT 网络分析法所获结果的质量很大程度上取决于事先对活动事件的预测，若能对各项活动的先后次序和完成时间都能有较为准确的预测，则通过 PERT 网络的分析法可大大缩短项目完成的时间14.3 地毯下面周进度评估、月进度评估。无论如何，提交真实的状态评估老板-监督小组-项目经理15. 另一面 流程图: 用于教学和解释，而不是程序前期设计。 程序文档 标签、声明语句 提高阅读可读性：尽可能的使用空格和一致的格式表现丛书和嵌套关系 以段落注释的形式，向程序中插入必要的记叙性文字16. 没有银弹 自行的进行市场调研，避免开发已上市的产品 在获取和制定软件需求时，将快速原型开发作为迭代计划的一部分 有机地更新软件，随着系统的运行、使用和测试，逐渐添加越来越多的功能 不断挑选和培养杰出的概念设计人员 解决复杂性的一些方法： 层次化，通过分层的模块或者对象 增量化，从而系统可以持续的运行","link":"/2022/09/14/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B/"},{"title":"《孤独小说家》","text":"石田衣良 平平淡淡的一本书，感觉就是作者在写自己的日常写作生活，以及为了拿直木奖的一些小凡尔赛。(ps：后来翻了一下直木奖获奖名单，发现里面居然有东野圭吾的《嫌疑人X的现身》)全书读下来就感觉一句话说的挺到位小说能把读者带入另一个世界，这或许才是小说最为珍贵的力量吧。","link":"/2022/02/27/%E3%80%8A%E5%AD%A4%E7%8B%AC%E5%B0%8F%E8%AF%B4%E5%AE%B6%E3%80%8B/"},{"title":"内网GitLab与PingCode打通","text":"公司是内网Gitlab所以配置的webhook没办法直接跟pingcode交互。然后就衍生出了这个奇奇怪怪的姿势：拥有外网访问权限的机器上创建一个jenkins任务 每隔两分钟利用Gitlab API获取每个分支的commit以及合并请求构建成webhook内容访问PingCode提供的接口，再通过PingCode提供的RESTful API同步工作状态及登记工时 Python脚本主要干了以下事情： 检测每个分支的提交，然后构建push的webhook提交到pingcode commit的title带上#+pingcode的任务编号(例:#D-123)关联提交次数 merge_request带上#+pingcode的任务编号关联到Merge state commit的title内容带上$[0-99](例: $4)登记工时 commit自动关联到任务的父任务 提交后自动将任务变更到“进行中”状态 检测每个往develop提交的合并请求，然后构建merge_request的webhook提交到pingcode 状态为opened时，将任务变更到“已完成｜已修复” 状态为merged时，将任务变更到“待验收” 合并后@任务创建人提示已经合并 其他 PingCode的工时登记API只能由个人token访问，所以需要在PingCode后台创建一个个人鉴权的凭证，回调地址随便填一个(例：https://open.pingcode.com) 再将应用链接发送给其他用户让其授权，授权后得到一个Code，再用Code获取用户Token。 获取Code 发送链接：https://open.pingcode.com/oauth2/authorize?response_type=code&amp;client_id={应用的Client ID} 获取Code：得到其他用户把回调链接中的Code 获取Token 访问API：https://open.pingcode.com/v1/auth/token?grant_type=authorization_code&amp;client_id=tvNKZvWrdLDb&amp;client_secret=xAyHtgVQwttiWYcYPMYzrVUa&amp;code={其他用户的Code} 存储Token：将API返回的信息记录到本地JSON中 附脚本(pingcode.py)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415#!/usr/bin/env python3# encoding: utf-8#__Author__ = 'lipenghui'__Date__ = '2021-12-30'from datetime import datetimefrom datetime import timedeltafrom itertools import countimport osimport sysimport timereload(sys)sys.setdefaultencoding('utf8')# need pip install python-gitlabimport gitlabimport jsonimport requestsimport reclass PingCode(): def __init__(self,url): self.STATE_TYPE_ING =0 #正在 self.STATE_TYPE_DONE =1 #完成 self.STATE_TYPE_CHECK =2 #验收 # 这部分状态在pingcode中不要删除 self.STATE_OPEN=&quot;61737417429e0dc6408d3211&quot; # 打开 self.STATE_NEW=&quot;61737417429e0dab368d320a&quot; # 新提交 self.STATE_PENDING=&quot;6177cbd05108bc6c9ed202a3&quot; # 待办 self.STATE_BUG_INPROGRESS=&quot;61737417429e0d5e638d320b&quot; # 处理中 普通提交改为此状态 self.STATE_BUG_FIXED=&quot;61737417429e0d71ba8d320c&quot; # 已修复 合并状态为opened改为此状态 self.STATE_TASK_INPROGRESS=&quot;61737417429e0d6b098d3212&quot; # 进行中 任务状态 self.STATE_INSCEPTION=&quot;6182336daffb9b86101e85ff&quot; # 待验收 合并状态为merged改为此状态 self.STATE_DONE=&quot;61737417429e0ddafb8d3213&quot; # 已完成 任务合并状态为opened改为此状态 self.headers={'Content-Type':'application/Json'} self.url=url self.openApi=&quot;https://open.pingcode.com&quot; self.client_id=&quot;&quot; self.client_secret=&quot;&quot; self.token=&quot;{鉴权Token}&quot; #要写绝对路径，否则Jenkins执行时会找不到文件 with open(&quot;pingcode.json&quot;,mode='r') as f: self.users=json.load(f) def getToken(self,userName=&quot;&quot;): # TODO 保存token，时间戳到本地，过期的时候重新获取，目前token持续90天 if False: body={ &quot;grant_type&quot;:&quot;client_credentials&quot;, &quot;client_id&quot;:&quot;gFsPGXQoxElx&quot;, &quot;client_secret&quot;:&quot;oDowultNitJJejutdLrqhRAc&quot; } www=requests.get(self.openApi+&quot;/v1/auth/token&quot;,headers=self.headers,params=body) response=json.loads(www.text) self.token=response[&quot;access_token&quot;] if self.users.has_key(userName): return self.users[userName][&quot;access_token&quot;] else: return self.token def push(self,content,commit,item): response=self.Send(json.dumps(content)) response=json.loads(response.text) if response.has_key(&quot;code&quot;): code=int(response[&quot;code&quot;]) if code==200 and item != None: #登记工时 workTimes=gitOperation.Get_workTimes(commit.title+commit.message) if len(workTimes)&gt;0: pingcode.registerManHours(commit.author_name,item[&quot;id&quot;],workTimes[0].replace(&quot;$&quot;,&quot;&quot;),commit.title) def merge(self,content,item,stateType,target): response=self.Send(json.dumps(content)) response=json.loads(response.text) if target==&quot;develop&quot; and response.has_key(&quot;code&quot;): code=int(response[&quot;code&quot;]) if code==200: pingcode.updateWorkItem(item[&quot;id&quot;],item,stateType) def Send(self,gitData): response=requests.post(url=self.url,headers=self.headers,data=gitData) print(response.text) return response #json.loads(response) def getWorkItem(self,identifier): url=self.openApi+&quot;/v1/agile/work_items&quot; body={ &quot;identifier&quot;:identifier, &quot;access_token&quot;:self.token } www=requests.get(url,headers=self.headers,params=body) response=json.loads(www.text) if response : if response.has_key(&quot;values&quot;): return response[&quot;values&quot;][0] else: print(response[&quot;message&quot;]) return None # 1.正在进行 2.已修复 3.待验收 # 合并@ def updateWorkItem(self,id,item,stateType): itemState=item[&quot;state&quot;][&quot;id&quot;] createById=item[&quot;created_by&quot;][&quot;id&quot;] createByName=item[&quot;created_by&quot;][&quot;display_name&quot;] # if (itemState==self.STATE_OPEN or itemState==self.STATE_NEW or itemState==self.STATE_PENDING) and stateType==self.STATE_TYPE_ING: if item[&quot;type&quot;]==&quot;bug&quot;: self.updateBug(id,item,stateType) elif item[&quot;type&quot;]==&quot;task&quot;: self.updateTask(id,item,stateType) # else: # print(&quot;workitem is in_progress or finish&quot;) content=&quot;&quot; if stateType==self.STATE_TYPE_DONE: # content=&quot;[auto] [@e40b744b3b3449c29d8ac9c92347964a|巫佳翔] 已发起和并请求，请及时处理&quot; pass elif stateType==self.STATE_TYPE_CHECK: content=&quot;[@&quot;+createById+&quot;|&quot;+createByName+&quot;] 已合并，请及时验收&quot; if content!=&quot;&quot;: self.commentWorkItem(id,content) def updateBug(self,id,item,stateType): url=self.openApi+&quot;/v1/agile/bugs/&quot;+id state_id=self.STATE_BUG_INPROGRESS if stateType==self.STATE_TYPE_ING: state_id=self.STATE_BUG_INPROGRESS elif stateType==self.STATE_TYPE_DONE: state_id=self.STATE_BUG_FIXED elif stateType==self.STATE_TYPE_CHECK: state_id=self.STATE_INSCEPTION param={ &quot;access_token&quot;:self.token } body={ &quot;state_id&quot;:state_id } www=requests.patch(url,headers=self.headers,params=param,data=json.dumps(body)) def updateTask(self,id,item,stateType): url=self.openApi+&quot;/v1/agile/tasks/&quot;+id state_id=self.STATE_BUG_INPROGRESS if stateType==self.STATE_TYPE_ING: state_id=self.STATE_TASK_INPROGRESS elif stateType==self.STATE_TYPE_DONE: state_id=self.STATE_DONE elif stateType==self.STATE_TYPE_CHECK: state_id=self.STATE_INSCEPTION param={ &quot;access_token&quot;:self.token } body={ &quot;state_id&quot;:state_id } www=requests.patch(url,headers=self.headers,params=param, data=json.dumps(body)) def commentWorkItem(self,identerfi,content): url=self.openApi+&quot;/v1/agile/work_items/&quot;+identerfi+&quot;/comments&quot; body={ &quot;content&quot;:content, &quot;access_token&quot;:self.token } www=requests.post(url, headers=self.headers,data=json.dumps(body)) print(&quot;commentWorkItem:&quot;+www.text) def registerManHours(self,userName,workItem,manHours,desp): &quot;&quot;&quot; 登记工时 &quot;&quot;&quot; userToken=self.getToken(userName) print(userName+&quot; cost :&quot;+&quot; &quot;+manHours +&quot; hours on work item:&quot;+workItem) url=self.openApi+&quot;/v1/agile/workloads&quot; manHours=float(manHours) param={ &quot;access_token&quot;:userToken } body={ &quot;work_item_id&quot;:workItem, &quot;workload_type_id&quot;:&quot;5cb7e7fffda1ce4ca0050002&quot;, &quot;duration&quot;:manHours, &quot;report_at&quot;:int(time.time()), &quot;description&quot;:desp } www=requests.post(url,headers=self.headers,params=param, data=json.dumps(body))class GitOperation(): def __init__(self,project): self.project={ &quot;id&quot;: project.id, &quot;name&quot;: project.name, &quot;description&quot;: project.description, &quot;web_url&quot;: project.web_url, &quot;avatar_url&quot;: &quot;&quot;, &quot;git_ssh_url&quot;: project.web_url, &quot;git_http_url&quot;: project.web_url, &quot;namespace&quot;: project.namespace, &quot;visibility_level&quot;: 0, &quot;path_with_namespace&quot;: project.path_with_namespace, &quot;default_branch&quot;: project.default_branch, &quot;ci_config_path&quot;: &quot;&quot;, &quot;homepage&quot;: project.web_url, &quot;url&quot;: project.web_url, &quot;ssh_url&quot;: project.web_url, &quot;http_url&quot;: project.web_url } self.repository= { &quot;name&quot;: &quot;rome&quot;, &quot;url&quot;: project.web_url, &quot;description&quot;: project.description, &quot;homepage&quot;: project.web_url, &quot;git_http_url&quot;: project.http_url_to_repo, &quot;git_ssh_url&quot;: project.web_url, &quot;visibility_level&quot;: 0 } def Get_workTimes(self,content): &quot;&quot;&quot; 获取提交说明中的工时信息 每次提交的工时记录需要低于10小时 &quot;&quot;&quot; pattern=re.compile(r'\\$\\d{,2}[\\.\\d{,1}]{,2}') workItems=pattern.findall(content) return workItems def Get_WorkItems(self,content): &quot;&quot;&quot; 获取提交说明中的任务编号&quot;&quot;&quot; pattern=re.compile(r'D-\\d{,6}') workItems=pattern.findall(content) return workItems def Get_Git_Commit_Dict(self,commit): return { &quot;id&quot;: commit.id, &quot;parent&quot;:commit.parent_ids, &quot;message&quot;: commit.message, &quot;title&quot;: commit.title, &quot;timestamp&quot;: commit.committed_date, &quot;url&quot;: self.project[&quot;web_url&quot;]+&quot;/commit/&quot;+commit.id, &quot;author&quot;: { &quot;name&quot;: commit.author_name, &quot;email&quot;: commit.author_email }, &quot;added&quot;: [], &quot;modified&quot;: [], &quot;removed&quot;: [] } def Get_Event_Merge(self,merge): &quot;&quot;&quot; 构建Merge_request的webhook格式请求json &quot;&quot;&quot; request={ &quot;object_kind&quot;: &quot;merge_request&quot;, &quot;event_type&quot;: &quot;merge_request&quot;, &quot;user&quot;: { &quot;id&quot;: merge.author[&quot;id&quot;], &quot;name&quot;: merge.author[&quot;name&quot;], &quot;username&quot;: merge.author[&quot;username&quot;], &quot;avatar_url&quot;: merge.author[&quot;avatar_url&quot;], &quot;email&quot;: &quot;[REDACTED]&quot; }, &quot;project&quot;:self.project, &quot;object_attributes&quot;: { &quot;assignee_id&quot;: merge.assignee, &quot;author_id&quot;: merge.author[&quot;id&quot;], &quot;created_at&quot;: merge.created_at, &quot;description&quot;: merge.description, &quot;head_pipeline_id&quot;: None, &quot;id&quot;: merge.id, &quot;iid&quot;: merge.iid, &quot;last_edited_at&quot;: None, &quot;last_edited_by_id&quot;: None, &quot;merge_commit_sha&quot;: merge.merge_commit_sha, &quot;merge_error&quot;: None, &quot;merge_params&quot;: { &quot;force_remove_source_branch&quot;: merge.force_remove_source_branch }, &quot;merge_status&quot;: merge.merge_status, &quot;merge_user_id&quot;:None, &quot;merge_when_pipeline_succeeds&quot;: merge.merge_when_pipeline_succeeds, &quot;milestone_id&quot;: None, &quot;source_branch&quot;: merge.source_branch, &quot;source_project_id&quot;: merge.source_project_id, &quot;state_id&quot;: 1, &quot;target_branch&quot;: merge.target_branch, &quot;target_project_id&quot;: merge.target_project_id, &quot;time_estimate&quot;: 0, &quot;title&quot;: merge.title, &quot;updated_at&quot;: merge.updated_at, &quot;updated_by_id&quot;: None, &quot;url&quot;: merge.web_url, &quot;source&quot;: self.project, &quot;target&quot;: self.project, &quot;work_in_progress&quot;: merge.work_in_progress, &quot;total_time_spent&quot;: 0, &quot;time_change&quot;: 0, &quot;human_total_time_spent&quot;: None, &quot;human_time_change&quot;: None, &quot;human_time_estimate&quot;: None, &quot;assignee_ids&quot;: [], &quot;state&quot;: merge.state, &quot;action&quot;: &quot;open&quot; }, &quot;labels&quot;: [ ], &quot;changes&quot;: { &quot;merge_status&quot;: { &quot;previous&quot;: &quot;unchecked&quot;, &quot;current&quot;: merge.merge_status } }, &quot;repository&quot;: self.repository } if merge.state==&quot;opened&quot;: pass elif merge.state==&quot;closed&quot;: pass elif merge.state==&quot;merged&quot;: # print(str(merge.merged_by[&quot;id&quot;])+&quot;合的&quot;) request[&quot;object_attributes&quot;][&quot;merge_user_id&quot;]= merge.merged_by[&quot;id&quot;] # print(request) return request def Get_Event_Push(self,branchName,commit): &quot;&quot;&quot; 构建push的webhook格式请求json &quot;&quot;&quot; branchName=branchName.replace(&quot;优化&quot;,&quot;youhua&quot;) gitCommit=self.Get_Git_Commit_Dict(commit) commits=[] commits.append(gitCommit) return { &quot;object_kind&quot;: &quot;push&quot;, &quot;event_name&quot;:&quot;push&quot;, &quot;before&quot;: commit.parent_ids[0], &quot;after&quot;: commit.id, &quot;ref&quot;: &quot;refs/heads/&quot;+branchName, &quot;checkout_sha&quot;: commit.id, &quot;user_id&quot;: 35, &quot;user_name&quot;: commit.author_name, &quot;user_username&quot;: commit.author_name, &quot;user_email&quot;: commit.author_email, &quot;user_avatar&quot;: &quot;https://www.gravatar.com/avatar/e96f394d1e9a973845ee60a6a73535de?s=80&amp;d=identicon&quot;, # &quot;project_id&quot;: self.project_id, &quot;project&quot;: self.project, &quot;repository&quot;: self.repository, &quot;commits&quot;: commits, &quot;total_commits_count&quot;: 1, &quot;push_options&quot;: {} }class GitlabAPI(): def __init__(self, *args, **kwargs): #绝对路径 if os.path.exists(&quot;python-gitlab.cfg&quot;): self.gl = gitlab.Gitlab.from_config('lipenghui', ['python-gitlab.cfg']) # elif os.path.exists(os.getenv('HOME')+'/.python-gitlab.cfg'): # self.gl = gitlab.Gitlab.from_config('lipenghui', [os.getenv('HOME') + '/.python-gitlab.cfg']) else: print('You need to make sure there is a file named &quot;/python-gitlab.cfg&quot; or &quot;~/.python-gitlab.cfg&quot;') sys.exit(5)if __name__ == '__main__': api=&quot;https://apps.pingcode.com/gitlab/api/webhooks/{PingCode侧GitLab的ClientId}&quot; pingcode=PingCode(api) gitApi = GitlabAPI() project = gitApi.gl.projects.get(1) gitOperation=GitOperation(project) tmpNow=datetime.now() if True: #时区问题 -8 now=tmpNow+timedelta(hours=-8,minutes=-2) last=now.strftime('%Y-%m-%dT%H:%M')#datetime.strptime(,'%YYYY-%MM-%DD %HH:%MM').isoformat() if True: # commit branches=project.branches.list(per_page=100) print(&quot;[&quot;+last+&quot;]=&gt; ready to sync commits into pingcode...&quot;) for branch in branches: # print(&quot;check commit:&quot;+branch.name+&quot; Time:&quot;+last) commits=project.commits.list(ref_name=branch.name,since=last) for commit in commits: identifiers=gitOperation.Get_WorkItems(commit.title) item=None for identifier in identifiers: item=pingcode.getWorkItem(identifier) #关联父任务 print(&quot;identifier:&quot;+identifier) if item and item.has_key(&quot;parent&quot;) and item[&quot;parent&quot;]: commit.message=commit.message+&quot; #&quot;+item[&quot;parent&quot;][&quot;identifier&quot;] pingcode.updateWorkItem(item[&quot;id&quot;],item,pingcode.STATE_TYPE_ING) # 同步提交日志 content=gitOperation.Get_Event_Push(branch.name,commit) pingcode.push(content,commit,item) if True : # merge # 不知道为什么gitlab服务器上会少6分钟 now=tmpNow+timedelta(hours=-8,minutes=-8) last=now.strftime('%Y-%m-%dT%H:%M')#datetime.strptime(,'%YYYY-%MM-%DD %HH:%MM').isoformat() print(&quot;[&quot;+last+&quot;]=&gt; ready to sync merges into pingcode...&quot;) merges= gitApi.gl.mergerequests.list(scope=&quot;all&quot;,updated_after=last) for merge in merges: mrg=project.mergerequests.get(merge.iid) commits=mrg.commits() if len(commits)&gt;1: for commit in commits: isPingcodeWorkItem=gitOperation.Get_WorkItems(commit.title) if len(isPingcodeWorkItem)&gt;0: itemId=isPingcodeWorkItem[0] if merge.title.find(itemId)&lt;0: merge.title+=&quot; &quot;+itemId merge.description+=&quot; &quot;+itemId # print(mrg.title+&quot; =&gt;&quot;+mrg.state+&quot;=&gt; commits:&quot;+str(len(commits))+&quot; =&gt; &quot;+merge.description) stateType=pingcode.STATE_TYPE_ING if mrg.state==&quot;merged&quot;: stateType=pingcode.STATE_TYPE_CHECK elif mrg.state==&quot;closed&quot;: stateType=pingcode.STATE_TYPE_ING elif mrg.state==&quot;opened&quot;: stateType=pingcode.STATE_TYPE_DONE # &quot;D&quot; 是pingcode后台项目的标识符 固定格式:D-123456 identifiers=gitOperation.Get_WorkItems(merge.title) for identifier in identifiers: item=pingcode.getWorkItem(identifier) Content=gitOperation.Get_Event_Merge(merge) pingcode.merge(Content,item,stateType,merge.target_branch) PingCode配置文件(pingcode.json)12345678910{ &quot;{GitLab账号}&quot;:{ &quot;name&quot;:&quot;李鹏辉&quot;, &quot;access_token&quot;: &quot;{接口返回}&quot;, &quot;token_type&quot;: &quot;{接口返回}&quot;, &quot;expires_in&quot;: &quot;{接口返回}&quot;, &quot;refresh_token&quot;: &quot;{接口返回}&quot;, &quot;code&quot;:&quot;{其他用户的Code}&quot; }} Json配置文件两部分[Key:Value]： key:其他用户在Gitlab上的用户名 value: name:用户名字 PingCode的Token信息(获取方法见后述) access_token token_type expires_in：过期时间，默认90天 refresh_token：刷新Token的参数 GitLab配置文件(gitlab.cfg)12345678[global]default ={GitLab登录账号}ssh_verify = Falsetimeout = 8[{GitLab登录账号}]url = http://{GitLab仓库地址}private_token = {GitLab个人账号创建的Token}api_version = 4","link":"/2022/02/27/%E5%86%85%E7%BD%91GitLab%E4%B8%8EPingCode%E6%89%93%E9%80%9A/"},{"title":"《沉默的大多数》","text":"古往今来最大的弱势群体：沉默的大多数。 这些人保持沉默的原因多种多样，有些人没能力或者没有机会说话；还有些人有隐情不便说话；还有一些人，因为种种原因，对于话语的世界有某种厌恶之情。我就属于这最后一种人。作为最后这种人，我有义务谈谈自己的所见所闻。 恕我直言，能够带来思想快乐的东西，只能是人类智慧至高的产物。比这再低一档的东西，只会给人带来痛苦，而这种低档货，就是出于功利的种种东西。","link":"/2022/02/27/%E3%80%8A%E6%B2%89%E9%BB%98%E7%9A%84%E5%A4%A7%E5%A4%9A%E6%95%B0%E3%80%8B/"},{"title":"热更新方案《huatuo》尝鲜","text":"开源地址: huatuo 现在市面上使用比较多的就是xlua等几个lua热更方案，纯c#的热更方案有ilruntime。每个方案都有各自存在的道理，水群里面经常出来一些“干死lua”之类的声音,这事儿在我看duck不必。我不喜欢lua的原因是因为引擎本身就有一层黑盒子 用了lua之后把游戏代码又封了一层。层层加码之后实际上阻碍了团队部分人员能力的提升.回到正题。项目目前用的是ILRuntime，因为是第一个unity项目，团队成员对unity以及c#的把控能力不高出现了以下一些问题: 频繁的添加适配器 频繁的添加委托 AOT裁减 就目前而言huatuo宣称上能够很好的解决以上的部分问题，使用起来简易不少。问题比较大就是对il2cpp的代码入侵较大，在没有成功上线项目下感觉要趟不少坑。跟着官方项目走基本能熟悉流程；我用自己的项目从ILRuntime切到华佗后遇到了以下一些问题： 打包的Mac项目报找不到imageplayersetting里面需要把ios也选上.NET 4.x [Android] * error only support 64bit。顾命思议,playsetting那边勾选arm64,自己的SDK工程中的Gradle也需要进行对应的64位调整 123ndk { abiFilters 'arm64-v8a'} [裁减] TypeLoadException: Could not load type ‘System.ValueTuple`6’。 需要在主工程中添加对应的ValueTuple,不太友好，看不到ValueTuple对应的参数类型。在一些如果是dll插件的话比较难定位 [裁减]Could not load type ‘System.Lazy`1’。同上 参考: unity代码防裁减 截止到现在游戏项目仍然没能在手机上跑起来….附上一些调试步骤 安卓真机crash后会有以下一些信息 123456789101112E/CRASH: backtrace:E/CRASH: #00 pc 0000000000aa20ac libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #01 pc 0000000000aa0534 libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #02 pc 0000000000a9f860 libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #03 pc 0000000000a9f74c libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #04 pc 000000000093c354 libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #05 pc 000000000091c7a0 libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #06 pc 0000000001582288 libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #07 pc 00000000011dd77c libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #08 pc 00000000011dcdcc libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #09 pc 00000000007bf4e8 libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f)E/CRASH: #10 pc 000000000093f044 libil2cpp.so (BuildId: 78b0ff9a36c4fbf64f45dd27cb7f4cc5a15cdc9f) 直接就用NDK(引擎安装目录:/Applications/Unity/Hub/Editor/2020.3.7f1c1/PlaybackEngines/AndroidPlayer/NDK/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line)中的工具获取so的符号表定位到对应的行号 参考 bugly符号表上传 unity导出的AndroidStudion工程从gradle中可以看到把带符号表的so生成到了unityLibrary/symbols/arm64-v8a/中 12345678910111213141516171819202122def BuildIl2Cpp(String workingDir, String targetDirectory, String architecture, String abi, String configuration) { exec { commandLine(workingDir + &quot;/src/main/Il2CppOutputProject/IL2CPP/build/deploy/netcoreapp3.1/il2cpp&quot;, &quot;--compile-cpp&quot;, &quot;--libil2cpp-static&quot;, &quot;--platform=Android&quot;, &quot;--architecture=&quot; + architecture, &quot;--configuration=&quot; + configuration, &quot;--outputpath=&quot; + workingDir + targetDirectory + abi + &quot;/libil2cpp.so&quot;, &quot;--cachedirectory=&quot; + workingDir + &quot;/build/il2cpp_&quot;+ abi + &quot;_&quot; + configuration + &quot;/il2cpp_cache&quot;, &quot;--additional-include-directories=&quot; + workingDir + &quot;/src/main/Il2CppOutputProject/IL2CPP/external/bdwgc/include&quot;, &quot;--additional-include-directories=&quot; + workingDir + &quot;/src/main/Il2CppOutputProject/IL2CPP/libil2cpp/include&quot;, &quot;--tool-chain-path=&quot; + android.ndkDirectory, &quot;--map-file-parser=&quot; + workingDir + &quot;/src/main/Il2CppOutputProject/IL2CPP/MapFileParser/MapFileParser.exe&quot;, &quot;--generatedcppdir=&quot; + workingDir + &quot;/src/main/Il2CppOutputProject/Source/il2cppOutput&quot;, &quot;--baselib-directory=&quot; + workingDir + &quot;/src/main/jniStaticLibs/&quot; + abi, &quot;--dotnetprofile=unityaot&quot;) environment &quot;ANDROID_SDK_ROOT&quot;, getSdkDir() } delete workingDir + targetDirectory + abi + &quot;/libil2cpp.sym.so&quot; ant.move(file: workingDir + targetDirectory + abi + &quot;/libil2cpp.dbg.so&quot;, tofile: workingDir + &quot;/symbols/&quot; + abi + &quot;/libil2cpp.so&quot;)} 命令行(-f -C -e 这些参数通过 -h看对应的描述;方便后续查问题,把aarch64-linux-android-addr2line加到环境变量里面) 1aarch64-linux-android-addr2line -f -C -e proj.android/unityLibrary/symbols/arm64-v8a/libil2cpp.so 0000000000aa20ac 0000000000aa0534 0000000000a9f860 结果如下 123456huatuo::metadata::Image::InitConsts()proj.android/unityLibrary/src/main/Il2CppOutputProject/IL2CPP/libil2cpp/huatuo/metadata/Image.cpp:366huatuo::metadata::Image::InitRuntimeMetadatas()proj.android/unityLibrary/src/main/Il2CppOutputProject/IL2CPP/libil2cpp/huatuo/metadata/Image.cpp:110huatuo::metadata::Assembly::Create(unsigned char const*, unsigned long, bool)SDK/proj.android/unityLibrary/src/main/Il2CppOutputProject/IL2CPP/libil2cpp/huatuo/metadata/Assembly.cpp:118 感受 工作流欠缺 类似ILRuntime的CLR绑定 引用 蓝大 蓝色幻想的话就是：clr自动分析绑定，你值得拥有 这玩意非常一大用处就是防泛型剪裁，是唯一可靠的途径。CLR绑定 泛型友好提示。类似ILRuntime在缺少Delegate时候的提示： 1appdomain.DelegateManager.RegisterFunctionDelegate&lt;UnityEngine.GameObject, System.Boolean&gt;(); 还没看到有项目说在用 其他已知问题 protobuf-net 不支持v.2.x之后的版本，r668可用 json 库名称 是否可用 utf8json 是 newtonsoftjson 是 catjson 是 litjson -","link":"/2022/04/02/%E7%83%AD%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88%E3%80%8Ahuatuo%E3%80%8B%E5%B0%9D%E9%B2%9C/"},{"title":"Unity序列帧播放器","text":"Unity序列帧播放器 核心: 帧率 播放下一帧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151using UnityEngine;using UnityEngine.UI;using System;/// &lt;summary&gt;/// 序列帧动画播放器/// 支持UGUI的Image和Unity2D的SpriteRenderer/// &lt;/summary&gt;public class FrameAnimator : MonoBehaviour{ /// &lt;summary&gt; /// 序列帧 /// &lt;/summary&gt; public Sprite[] Frames{ get { return frames; } set { frames = value; } } [SerializeField]private Sprite[] frames = null; /// &lt;summary&gt; /// 帧率，为正时正向播放，为负时反向播放 /// &lt;/summary&gt; public float Framerate { get { return framerate; } set { framerate = value; } } [SerializeField] private float framerate = 20.0f; /// &lt;summary&gt; /// 是否忽略timeScale /// &lt;/summary&gt; public bool IgnoreTimeScale{ get { return ignoreTimeScale; } set { ignoreTimeScale = value; } } [SerializeField]private bool ignoreTimeScale = true; /// &lt;summary&gt; /// 是否循环 /// &lt;/summary&gt; public bool Loop{ get { return loop; } set { loop = value; } } [SerializeField]private bool loop = true; //动画曲线 [SerializeField]private AnimationCurve curve = new AnimationCurve (new Keyframe (0, 1, 0, 0), new Keyframe (1, 1, 0, 0)); /// 结束事件 public event Action FinishEvent; //目标Image组件 private Image image; //目标SpriteRenderer组件 private SpriteRenderer spriteRenderer; //当前帧索引 private int currentFrameIndex = 0; //下一次更新时间 private float timer = 0.0f; //当前帧率，通过曲线计算而来 private float currentFramerate = 20.0f; // 重设动画 public void Reset () { currentFrameIndex = framerate &lt; 0 ? frames.Length - 1 : 0; } // 从停止的位置播放动画 public void Play () { this.enabled = true; } /// 暂停动画 public void Pause () { this.enabled = false; } /// 停止动画，将位置设为初始位置 public void Stop () { Pause (); Reset (); } //自动开启动画 void Start () { image = this.GetComponent&lt;Image&gt; (); spriteRenderer = this.GetComponent&lt;SpriteRenderer&gt; ();#if UNITY_EDITOR if (image == null &amp;&amp; spriteRenderer == null) { Debug.LogWarning (&quot;No available component found. 'Image' or 'SpriteRenderer' required.&quot;, this.gameObject); }#endif } void Update () { //帧数据无效，禁用脚本 if (frames == null || frames.Length == 0) { this.enabled = false; } else { //从曲线值计算当前帧率 float curveValue = curve.Evaluate ((float)currentFrameIndex / frames.Length); float curvedFramerate = curveValue * framerate; //帧率有效 if (curvedFramerate != 0) { //获取当前时间 float time = ignoreTimeScale ? Time.unscaledTime : Time.time; //计算帧间隔时间 float interval = Mathf.Abs (1.0f / curvedFramerate); //满足更新条件，执行更新操作 if (time - timer &gt; interval) { //执行更新操作 DoUpdate (); } }#if UNITY_EDITOR else { Debug.LogWarning (&quot;Framerate got '0' value, animation stopped.&quot;); }#endif } } //具体更新操作 private void DoUpdate () { //计算新的索引 int nextIndex = currentFrameIndex + (int)Mathf.Sign (currentFramerate); //索引越界，表示已经到结束帧 if (nextIndex &lt; 0 || nextIndex &gt;= frames.Length) { //广播事件 if (FinishEvent != null) { FinishEvent (); } //非循环模式，禁用脚本 if (loop == false) { currentFrameIndex = Mathf.Clamp (currentFrameIndex, 0, frames.Length - 1); this.enabled = false; return; } } currentFrameIndex = nextIndex % frames.Length; //更新图片 if (image != null) { image.sprite = frames [currentFrameIndex]; } else if (spriteRenderer != null) { spriteRenderer.sprite = frames [currentFrameIndex]; } //设置计时器为当前时间 timer = ignoreTimeScale ? Time.unscaledTime : Time.time; }}","link":"/2022/03/03/Unity%E5%BA%8F%E5%88%97%E5%B8%A7%E6%92%AD%E6%94%BE%E5%99%A8/"},{"title":"TeamCity工作流(一)","text":"1 前言关于TeamCity的安装教程以及Unity插件安装无需赘述，参考:工作流篇（2）： TeamCity，15分钟搭建U3d CI环境，自动测试、版本发布、部署 目前项目热更新方案是使用的HybridCLR；资源管理使用的是YooAsset. 整个构建过程是囊括了以上两个方案的流程。 2 版本控制2.1 VCS checkout目前项目分支结构为 v1/release、v1/hotfix。出包使用release分支，同时将release分支内容同步到hotfix分支，后续热更新往hotfix分支提交。需要出新包的时候就是新建v2/release分支。 起初是准备在TeamCity上面创建两个Build，分别监听hotfix和release分支 为了省一点硬盘空间 将两个Build的目录指向同一个，但两个不同Build启动的时候会将当前目录清空，重新拉取仓库内容，unity切换平台导入资源每次都会耗时2个小时，所以后来hotfix、release共用一个Build，构建步骤用条件进行区分头三个checkout模式在两个不同的Build任务执行时都会将当前的目录重新checkout，最后作罢选择了两个流程共用一个Build。 2.2 Artifactjenkins中每个step可以做一些成功或失败后的操作，TeamCity这边暂时没发现。所以release分支及hotfix分支的构建产物我直接在 Artifact paths中一起配置了，构建成功之后没收集到对应规则的产物会有警告，但不会终止当前构建。 例： 12+:release/%build.number%.apk+:Bundles/Android/%build.number% =&gt; %build.number% 3 构建流程3.1 出包流程整理如下图出包期间会执行到HybridCLR与YooAsset的构建过程 3.1.1 流程大概 HybridCLR: 出一次包:获取裁剪后的dll 生成桥接函数(如果有新增) 编译hotfix部分的dll 重新出包 YooAsset的大概流程为: 调用AssetBundleBuilder的Run方法就好了(需要提前给到一些参数的,例如:构建模式[增量、重构]；资源版本号等) 3.1.2 配置步骤 HybridCLR 编译DLL：CustomBuild.BuildDLL 编译HotFix工程:CustomBuild.BuildHotfixProject 导出工程: CustomBuild.Build YooAsset CustomBuild.BuildInternal 生成APK Flaovr参考之前的jenkins出包 Git提交代码 TeamCity不支持push操作，所以需要自己写命令行提交 在构建过程中手动push会触发配置的分支Triggers，所以先禁用Trigger，但build就变成了半自动 挖个坑:尝试使用TeamCity的Dependencies，让增量更新依赖上次的构建，这样就不用从git上拉取之前的版本内容了 Gradle任务中的自定义参数在Additional Gradle command line parameters中填写，需要注意的是参数前面需要追加一个“-P”不留空格。这样就可以将值传到AndroidStudio工程gradle.properties 中的配置字段了伪代码部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class CustomBuild{ ///&lt;summary&gt; ///BuildDll伪代码 ///&lt;/summary&gt; public static void BuildDLL() { string[] args = System.Environment.GetCommandLineArgs();//获取命令行参数 var outDir = System.Environment.CurrentDirectory + &quot;/../output/&quot; + buildTarget.ToString(); //...do something string[] scenes = new[] { &quot;Assets/Main.unity&quot; }; PlayerSettings.SetScriptingBackend(buildTargetGroup, ScriptingImplementation.IL2CPP); BuildPipeline.BuildPlayer(scenes, outDir, buildTarget, BuildOptions.CompressWithLz4); } ///&lt;summary&gt; ///HotFix工程编译伪代码 ///&lt;/summary&gt; public static void BuildHotfixProject(BuildTarget target) { //HybridCLR编译DLL HybridCLR.Editor.CompileDllCommand.CompileDll(target); //复制DLL到资源目录 string dllPath = $&quot;{HybridCLR.Editor.SettingsUtil.GetHotFixDllsOutputDirByTarget(target)}/{dll}&quot;; var myPath = &quot;xxx/xxx/xxx.bytes&quot;; File.Copy(dllPath, myPath, true); //dll加密 //EncryptStaticData(); } ///&lt;summary&gt; ///资源构建伪代码 ///&lt;/summary&gt; public static void BuildInternal() { string[] args = System.Environment.GetCommandLineArgs(); //获取目标平台参数:args[i]==&quot;-buildTarget&quot; //获取资源版本号参数: args[i] == &quot;-buildVersion&quot; //获取构建模式:args[i]==&quot;-buildType&quot;(EBuildMode.ForceRebuild、EBuildMode.IncrementalBuild) // YooAsset构建参数 string defaultOutputRoot = AssetBundleBuilderHelper.GetDefaultOutputRoot(); BuildParameters buildParameters = new BuildParameters(); buildParameters.VerifyBuildingResult = true; buildParameters.OutputRoot = defaultOutputRoot; buildParameters.BuildTarget = buildTarget; buildParameters.BuildVersion = buildVersion; buildParameters.CompressOption = ECompressOption.LZ4; //注意: //不追加后缀默认导出的的Android项目会因为unityStreamingAssets配置项中内容过长导致build失败 //1.追加后缀 //2.unityStreamingAssets内删除所有&quot;YooAsset/哈希&quot;内容 buildParameters.AppendFileExtension = true; buildParameters.BuildMode = buildType; // 执行构建 AssetBundleBuilder builder = new AssetBundleBuilder(); builder.Run(buildParameters); } TeamCity中有Unity插件 所以只需要在Execute method处填上对应的方法即可，其他追加的参数填在Command line arguments处。在jenkins中使用命令行操作 1&quot;%unity%&quot; -quit -batchmode -logFile log/${UNITY_LOG_BUILD_DLL} -projectPath ../unity -executeMethod CustomBuild.BuildDLL ${BUILD_TARGET} 3.2 资源更新资源更新部分其实就是把打包过程中YooAsset部分的构建模式换为增量，以及给一个版本号即可，YooAsset的增量更新每次都是把所有文件打出来了，为了节省上传时间及本地磁盘占用 我在YooAsset的任务中追加了一个剔除重复资源的BuildTask,每次打包的资源与首包进行对比。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Collections.Generic;using System.IO;using UnityEngine;namespace YooAsset.Editor{ [TaskAttribute(&quot;删除重复资源&quot;)] public class TaskDeleteDuplicate : IBuildTask { void IBuildTask.Run(BuildContext context) { var buildParameters = context.GetContextObject&lt;AssetBundleBuilder.BuildParametersContext&gt;(); var buildMode = buildParameters.Parameters.BuildMode; if (buildMode == EBuildMode.IncrementalBuild &amp;&amp; buildParameters.Parameters.DeleteDuplicate) { ComparePatch(buildParameters); } } private void ComparePatch(AssetBundleBuilder.BuildParametersContext buildParameters) { string packageDirectory = buildParameters.GetPackageDirectory(); PatchManifest patchManifest1 = AssetBundleBuilderHelper.LoadPatchManifestFile(buildParameters.PipelineOutputDirectory, 1); PatchManifest patchManifest2 = AssetBundleBuilderHelper.LoadPatchManifestFile(buildParameters.PipelineOutputDirectory, buildParameters.Parameters.BuildVersion); //删除重复资源 foreach (var patchBundle2 in patchManifest2.BundleList) { if (patchManifest1.Bundles.TryGetValue(patchBundle2.BundleName, out PatchBundle patchBundle1)) { if (patchBundle2.Hash == patchBundle1.Hash) { string delPath = $&quot;{packageDirectory}/{patchBundle2.Hash}&quot;; File.Delete(delPath); } else { Debug.Log($&quot;变动文件:{patchBundle2.BundleName}&quot;); } } else { Debug.Log($&quot;新增文件:{patchBundle2.BundleName}&quot;); } } Debug.Log(&quot;重复资源删除完成！&quot;); } }} 先结束","link":"/2022/10/14/TeamCity%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%B8%80/"},{"title":"TeamCity工作流(二)","text":"1.前言上一篇TeamCity大概介绍了开发、打包及更新流程，这篇继续上一篇遗留的一个问题不能自动化的问题。 2.TeamCity Dependent Build上一篇的流程中需要将YooAsset的增量包提交到仓库中所以不能在有变动时自动出包及制作更新包，就刚好利用TeamCity的依赖构建[1]先在基础设置中配置构建物收集目录目录支持*通配符，规则[2]大概就是从项目目录 =&gt; TeamCity目录，上述配置构建成功后可得到如下构建物：设置完Artifact Paths后，去设置一下Dependencies就YooAsset做更新而言(其他资源更新方式也是差不多的流程)，我配置了两个依赖： 首包资源（YooAsset首包会有一个1版本的资源目录及原始bundle资源目录UnityManifest） 增量资源：基于上一个版本构建出来的资源目录及版本号文件UnityManifest/StaticVersion.bytes 其中首包依赖中需要剔除版本为1的UnityManifest/StaticVersion.bytes 剔除规则就是用-:目录或者文件的形式，之所以要剔除是因为无法覆盖，会报错_(我遇到这个错了，但没有继续深究是否可以追加什么参数强制覆盖)_ 配置完成后可以点击Check artifact dependencies 按钮进行检查。 至此，当往hotfix分支提交或者合并的时候就会自动开始制作更新包并上传到CDN服务器上了。 3.遗留问题 Artifact paths 无法添加条件 因为我是release、hotfix两个分支共用了一个build，但有不同分支收集不同构建物的需求，但Artifact paths这边尚未找到指定分支或其他条件的办法 ,示例中也只是列举了通配符、打包zip等操作。所以我现在的出包和热更得有一个需要手动改一下路径 :( Artifact Dependency 下 必须存在依赖的Artifact在我第一次热更新的时候 实际上是没有上个热更包内容的，所以构建的时候会提示下载Artifact失败，必须先手动禁用这个依赖 :( 两个Artifact有同名文件时会合并出错这个后面再研究一下吧 最后，再研究一下Snapshot Dependencies 快照形式的构建能不能解决上述的头两个问题。以及还要再做一个release分支合并后批量生成APK的步骤。","link":"/2022/10/28/TeamCity%E5%B7%A5%E4%BD%9C%E6%B5%81%E4%BA%8C/"}],"tags":[{"name":"ci&#x2F;cd","slug":"ci-cd","link":"/tags/ci-cd/"},{"name":"工作","slug":"工作","link":"/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"pingcode","slug":"pingcode","link":"/tags/pingcode/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"工作","slug":"工作","link":"/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"}]}